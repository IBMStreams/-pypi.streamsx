# SPL_CGT_INCLUDE: ../pywrapfunction.cgt

package PyFunctionSource_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/* Additional includes go here */', "\n";
   print "\n";
   print '#include "splpy.h"', "\n";
   print '#include "splpy_funcop.h"', "\n";
   print "\n";
   print 'using namespace streamsx::topology;', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR() :', "\n";
   print '    funcop_(NULL),', "\n";
   print '    function_(NULL)', "\n";
   print '{', "\n";
   print '    funcop_ = new SplpyFuncOp(this);', "\n";
   print "\n";
   print '    SplpyGILLock lock;', "\n";
   print "\n";
   print '    PyObject *_module_;', "\n";
   print '    PyObject *_function_;', "\n";
   print "\n";
    my $pywrapfunc='iterableSource'; 
   print "\n";
    # setup the function that will be called to process
    # each tuple. the Perl variable $pywrapfunc must
    # be set to the name of the setup Python function
    # that will be called to wrap the user's function.
   
    my $pyModule =  $model->getParameterByName("pyModule")->getValueAt(0)->getCppExpression() . '.c_str()';
    my $pyCallableName = $model->getParameterByName("pyName")->getValueAt(0)->getCppExpression() . '.c_str()';
    my $pyCallable = $model->getParameterByName("pyCallable");
    $pyCallable = $pyCallable->getValueAt(0)->getCppExpression() . '.c_str()' if $pyCallable;
   print "\n";
   print "\n";
   print '    // pointer to the application function or callable class', "\n";
   print '    PyObject * appCallable = ', "\n";
   print '      SplpyGeneral::loadFunction(';
   print $pyModule;
   print ', ';
   print $pyCallableName;
   print ');', "\n";
   print "\n";
   print '    // The object to be called is either appCallable for', "\n";
   print '    // a function passed into the operator', "\n";
   print '    // or a pickled encoded class instance', "\n";
   print '    // represented as a string in parameter pyCallable', "\n";
   print '    ', "\n";
   print '    ';
    if ($pyCallable) { 
   print "\n";
   print '      // argument is the serialized callable instance', "\n";
   print '      Py_DECREF(appCallable);', "\n";
   print '      appCallable = pyUnicode_FromUTF8(';
   print $pyCallable;
   print ');', "\n";
   print '    ';
   }
   print "\n";
   print "\n";
   print '     PyObject * depickleInput = SplpyGeneral::loadFunction("streamsx.topology.runtime", "';
   print $pywrapfunc;
   print '");', "\n";
   print '    PyObject * funcArg = PyTuple_New(1);', "\n";
   print '    PyTuple_SET_ITEM(funcArg, 0, appCallable);', "\n";
   print '    function_ = PyObject_CallObject(depickleInput, funcArg);', "\n";
   print '    Py_DECREF(depickleInput);', "\n";
   print '    Py_DECREF(funcArg);', "\n";
   print '    if(function_ == 0){', "\n";
   print '      SplpyGeneral::flush_PyErr_Print();', "\n";
   print '      throw;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    // Finalization code goes here', "\n";
   print '    if (function_) {', "\n";
   print '      SplpyGILLock lock;', "\n";
   print '      Py_DECREF(function_);', "\n";
   print '    }', "\n";
   print "\n";
   print '    delete funcop_;', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '  createThreads(1);', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    SplpyOp::prepareToShutdown();', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '  while(!getPE().getShutdownRequested()) {', "\n";
   print '    ', "\n";
   print '    OPort0Type otuple;', "\n";
   print "\n";
   print '    { // start lock', "\n";
   print '      SplpyGILLock lock;', "\n";
   print '      PyObject * pyReturnVar = PyObject_CallObject(function_, NULL);', "\n";
   print '      if (SplpyGeneral::isNone(pyReturnVar)) {', "\n";
   print '        Py_DECREF(pyReturnVar);', "\n";
   print '        break;', "\n";
   print '      } else if(pyReturnVar == 0){', "\n";
   print '        SplpyGeneral::flush_PyErrPyOut();', "\n";
   print '        throw;', "\n";
   print '      }', "\n";
   print "\n";
   print '      pySplValueFromPyObject(otuple.get___spl_po(), pyReturnVar);', "\n";
   print '      Py_DECREF(pyReturnVar);', "\n";
   print "\n";
   print '    } // end lock', "\n";
   print "\n";
   print '    submit(otuple, 0);', "\n";
   print '  }', "\n";
   print "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
